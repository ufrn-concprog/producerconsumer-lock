# The producer-consumer problem: A solution using locks #

## About
This project implements a solution to the well-known [producer-consumer](https://en.wikipedia.org/wiki/Producer–consumer_problem) problem using locks. In the Java programming language, implementations of the [`Lock` interface](https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/concurrent/locks/Lock.html) have the same idea of synchronized methods for mutual exclusion of concurrent threads. Nonetheless, these classes provide more capabilities for synchronization control, besides allowing for the use of condition variables (implementations of the [`Condition` interface](https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/concurrent/locks/Condition.html) to suspend threads or notify them for execution under certain conditions.

## The producer-consumer problem
The producer-consumer problem refers to a data area (a bounded buffer) shared by two types of processes, producers and consumers. Producers generate and insert new elements into the shared buffer while consumers remove and consume elements from the shared buffer. The following constraints must be also satisfied:

* Only one operation (insertion or removal of elements into/from the buffer) can be performed at a time
* Producers cannot insert new elements when the buffer is full: they must be suspended
* Consumers cannot remove elements when the buffer is empty: they must be suspended
* Elements must be removed in the same order at which they were inserted

This solution to the problem consists in implementing the insertion and removal operations as statements controlled by a lock object. The thread attempts to acquire the lock before executing those statements. If the lock is granted (i.e., no other thread holds it in mutual exclusion), the thread executes the statements and releases the lock at the end. While the current size of the buffer is equal to the established capacity, producer threads should be suspended. If it is possible to add a new element to the buffer, then a consumer thread eventually suspended should be notified to resume execution. On the other hand, while the current size of the buffer is equal to zero, consumer threads should be suspended. If it is possible to remove an element from the buffer, then a producer thread eventually suspended should be notified to resume execution. These conditions for suspending threads or notiying them for execution are controlled via condition variables associated with the mutual exclusion lock.

## Repository structure
Source code in this repository is organized as follows:

```
+─producerconsumer-monitor            ---> Project directory
  ├─── doc                            ---> Directory with HTML pages resulted from generated Javadoc
  └─── src                            ---> Directory with source code files
       └─── Consumer.java             ---> Implementation of the consumer thread
       └─── Producer.java             ---> Implementation of the producer thread
       └─── ProducerConsumerMain.java ---> Main class
       └─── SharedBuffer.java         ---> Implementation of the shared buffer and the synchronized operations on it
```

After cloning this repository with `git clone` to your local file system, you can import it to your preferred IDE.
[Java Development Kit (JDK)](https://www.oracle.com/java/technologies/downloads/) is required to develop with and run 
this programs. HTML documentation is generated by running the `javadoc` command.

